{"version":3,"sources":["webpack:///webpack/bootstrap 79ef2ee813862f4b6ae1","webpack:///./subscriptionLink.postload.js","webpack:///./composer.postload.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;;;;;;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO,qDAAqD;;AAE5D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,GAAG;AAC1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,iCAAiC;AACrE,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,SAAS;AACT;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,GAAG;;AAEH;AACA,iCAAiC,uBAAuB;;AAExD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"include.postload.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 79ef2ee813862f4b6ae1","/*\n * This file is part of Adblock Plus <https://adblockplus.org/>,\n * Copyright (C) 2006-present eyeo GmbH\n *\n * Adblock Plus is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 3 as\n * published by the Free Software Foundation.\n *\n * Adblock Plus is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Adblock Plus.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n\"use strict\";\n\nif (document instanceof HTMLDocument)\n{\n  document.addEventListener(\"click\", event =>\n  {\n    // Ignore right-clicks\n    if (event.button == 2)\n      return;\n\n    // Ignore simulated clicks.\n    if (event.isTrusted == false)\n      return;\n\n    // Search the link associated with the click\n    let link = event.target;\n    while (!(link instanceof HTMLAnchorElement))\n    {\n      link = link.parentNode;\n\n      if (!link)\n        return;\n    }\n\n    let queryString = null;\n    if (link.protocol == \"http:\" || link.protocol == \"https:\")\n    {\n      if (link.host == \"subscribe.adblockplus.org\" && link.pathname == \"/\")\n        queryString = link.search.substr(1);\n    }\n    else\n    {\n      // Firefox 51 doesn't seem to populate the \"search\" property for\n      // links with non-standard URL schemes so we need to extract the query\n      // string manually.\n      let match = /^abp:\\/*subscribe\\/*\\?(.*)/i.exec(link.href);\n      if (match)\n        queryString = match[1];\n    }\n\n    if (!queryString)\n      return;\n\n    // This is our link - make sure the browser doesn't handle it\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Decode URL parameters\n    let title = null;\n    let url = null;\n    for (let param of queryString.split(\"&\"))\n    {\n      let parts = param.split(\"=\", 2);\n      if (parts.length != 2 || !/\\S/.test(parts[1]))\n        continue;\n      switch (parts[0])\n      {\n        case \"title\":\n          title = decodeURIComponent(parts[1]);\n          break;\n        case \"location\":\n          url = decodeURIComponent(parts[1]);\n          break;\n      }\n    }\n    if (!url)\n      return;\n\n    // Default title to the URL\n    if (!title)\n      title = url;\n\n    // Trim spaces in title and URL\n    title = title.trim();\n    url = url.trim();\n    if (!/^(https?|ftp):/.test(url))\n      return;\n\n    browser.runtime.sendMessage({\n      type: \"subscriptions.add\",\n      title,\n      url,\n      confirm: true\n    });\n  }, true);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./subscriptionLink.postload.js\n// module id = 1\n// module chunks = 0","/*\n * This file is part of Adblock Plus <https://adblockplus.org/>,\n * Copyright (C) 2006-present eyeo GmbH\n *\n * Adblock Plus is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 3 as\n * published by the Free Software Foundation.\n *\n * Adblock Plus is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Adblock Plus.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n\"use strict\";\n\n// We would rather export these properly and then require(\"./include.preload\")\n// here, but that would result in include.preload running both at pre and post\n// load.\nconst {checkCollapse, elemhide, getURLsFromElement, typeMap} = window;\n\n// The page ID for the popup filter selection dialog (top frame only).\nlet blockelementPopupId = null;\n\n// Element picking state (top frame only).\nlet currentlyPickingElement = false;\nlet lastMouseOverEvent = null;\n\n// During element picking this is the currently highlighted element. When\n// element has been picked this is the element that is due to be blocked.\nlet currentElement = null;\n\n// Highlighting state, used by the top frame during element picking and all\n// frames when the chosen element is highlighted red.\nlet highlightedElementsSelector = null;\nlet highlightedElementsInterval = null;\n\n// Last right click state stored for element blocking via the context menu.\nlet lastRightClickEvent = null;\nlet lastRightClickEventIsMostRecent = false;\n\n\n/* Utilities */\n\nfunction getFiltersForElement(element, callback)\n{\n  let src = element.getAttribute(\"src\");\n  browser.runtime.sendMessage({\n    type: \"composer.getFilters\",\n    tagName: element.localName,\n    id: element.id,\n    src: src && src.length <= 1000 ? src : null,\n    style: element.getAttribute(\"style\"),\n    classes: Array.prototype.slice.call(element.classList),\n    urls: getURLsFromElement(element),\n    mediatype: typeMap.get(element.localName),\n    baseURL: document.location.href\n  },\n  response =>\n  {\n    callback(response.filters, response.selectors);\n  });\n}\n\nfunction getBlockableElementOrAncestor(element, callback)\n{\n  // We assume that the user doesn't want to block the whole page.\n  // So we never consider the <html> or <body> element.\n  while (element && element != document.documentElement &&\n         element != document.body)\n  {\n    // We can't handle non-HTML (like SVG) elements, as well as\n    // <area> elements (see below). So fall back to the parent element.\n    if (!(element instanceof HTMLElement) || element.localName == \"area\")\n      element = element.parentElement;\n\n    // If image maps are used mouse events occur for the <area> element.\n    // But we have to block the image associated with the <map> element.\n    else if (element.localName == \"map\")\n    {\n      let images = document.querySelectorAll(\"img[usemap]\");\n      let image = null;\n\n      for (let currentImage of images)\n      {\n        let usemap = currentImage.getAttribute(\"usemap\");\n        let index = usemap.indexOf(\"#\");\n\n        if (index != -1 && usemap.substr(index + 1) == element.name)\n        {\n          image = currentImage;\n          break;\n        }\n      }\n\n      element = image;\n    }\n\n    // Finally, if none of the above is true, check whether we can generate\n    // any filters for this element. Otherwise fall back to its parent element.\n    else\n    {\n      getFiltersForElement(element, filters =>\n      {\n        if (filters.length > 0)\n          callback(element);\n        else\n          getBlockableElementOrAncestor(element.parentElement, callback);\n      });\n\n      return;\n    }\n  }\n\n  // We reached the document root without finding a blockable element.\n  callback(null);\n}\n\n\n/* Element highlighting */\n\n// Adds an overlay to an element in order to highlight it.\nfunction addElementOverlay(element)\n{\n  let position = \"absolute\";\n  let offsetX = window.scrollX;\n  let offsetY = window.scrollY;\n\n  for (let e = element; e; e = e.parentElement)\n  {\n    let style = getComputedStyle(e);\n\n    // If the element isn't rendered (since its or one of its ancestor's\n    // \"display\" property is \"none\"), the overlay wouldn't match the element.\n    if (style.display == \"none\")\n      return null;\n\n    // If the element or one of its ancestors uses fixed postioning, the overlay\n    // must too. Otherwise its position might not match the element's.\n    if (style.position == \"fixed\")\n    {\n      position = \"fixed\";\n      offsetX = offsetY = 0;\n    }\n  }\n\n  let overlay = document.createElement(\"div\");\n  overlay.prisoner = element;\n  overlay.className = \"__adblockplus__overlay\";\n  overlay.setAttribute(\"style\",\n                       \"opacity:0.4; display:inline-block !important; \" +\n                       \"overflow:hidden; box-sizing:border-box;\");\n  let rect = element.getBoundingClientRect();\n  overlay.style.width = rect.width + \"px\";\n  overlay.style.height = rect.height + \"px\";\n  overlay.style.left = (rect.left + offsetX) + \"px\";\n  overlay.style.top = (rect.top + offsetY) + \"px\";\n  overlay.style.position = position;\n  overlay.style.zIndex = 0x7FFFFFFE;\n\n  document.documentElement.appendChild(overlay);\n  return overlay;\n}\n\nfunction highlightElement(element, shadowColor, backgroundColor)\n{\n  unhighlightElement(element);\n\n  let highlightWithOverlay = () =>\n  {\n    let overlay = addElementOverlay(element);\n\n    // If the element isn't displayed no overlay will be added.\n    // Moreover, we don't need to highlight anything then.\n    if (!overlay)\n      return;\n\n    highlightElement(overlay, shadowColor, backgroundColor);\n    overlay.style.pointerEvents = \"none\";\n\n    element._unhighlight = () =>\n    {\n      overlay.parentNode.removeChild(overlay);\n    };\n  };\n\n  let highlightWithStyleAttribute = () =>\n  {\n    let originalBoxShadow = element.style.getPropertyValue(\"box-shadow\");\n    let originalBoxShadowPriority =\n      element.style.getPropertyPriority(\"box-shadow\");\n    let originalBackgroundColor =\n      element.style.getPropertyValue(\"background-color\");\n    let originalBackgroundColorPriority =\n      element.style.getPropertyPriority(\"background-color\");\n\n    element.style.setProperty(\"box-shadow\", \"inset 0px 0px 5px \" + shadowColor,\n                              \"important\");\n    element.style.setProperty(\"background-color\", backgroundColor, \"important\");\n\n    element._unhighlight = () =>\n    {\n      element.style.removeProperty(\"box-shadow\");\n      element.style.setProperty(\n        \"box-shadow\",\n        originalBoxShadow,\n        originalBoxShadowPriority\n      );\n\n      element.style.removeProperty(\"background-color\");\n      element.style.setProperty(\n        \"background-color\",\n        originalBackgroundColor,\n        originalBackgroundColorPriority\n      );\n    };\n  };\n\n  // If this element is an overlay that we've created previously then we need\n  // to give it a background colour. Otherwise we need to create an overlay\n  // and then recurse in order to set the overlay's background colour.\n  if (\"prisoner\" in element)\n    highlightWithStyleAttribute();\n  else\n    highlightWithOverlay();\n}\n\nfunction unhighlightElement(element)\n{\n  if (element && \"_unhighlight\" in element)\n  {\n    element._unhighlight();\n    delete element._unhighlight;\n  }\n}\n\n// Highlight elements matching the selector string red.\n// (All elements that would be blocked by the proposed filters.)\nfunction highlightElements(selectorString)\n{\n  unhighlightElements();\n\n  let elements = Array.prototype.slice.call(\n    document.querySelectorAll(selectorString)\n  );\n  highlightedElementsSelector = selectorString;\n\n  // Highlight elements progressively. Otherwise the page freezes\n  // when a lot of elements get highlighted at the same time.\n  highlightedElementsInterval = setInterval(() =>\n  {\n    if (elements.length > 0)\n    {\n      let element = elements.shift();\n      if (element != currentElement)\n        highlightElement(element, \"#fd6738\", \"#f6e1e5\");\n    }\n    else\n    {\n      clearInterval(highlightedElementsInterval);\n      highlightedElementsInterval = null;\n    }\n  }, 0);\n}\n\n// Unhighlight the elements that were highlighted by selector string previously.\nfunction unhighlightElements()\n{\n  if (highlightedElementsInterval)\n  {\n    clearInterval(highlightedElementsInterval);\n    highlightedElementsInterval = null;\n  }\n\n  if (highlightedElementsSelector)\n  {\n    Array.prototype.forEach.call(\n      document.querySelectorAll(highlightedElementsSelector),\n      unhighlightElement\n    );\n\n    highlightedElementsSelector = null;\n  }\n}\n\n\n/* Input event handlers */\n\nfunction stopEventPropagation(event)\n{\n  event.stopPropagation();\n}\n\n// Hovering over an element so highlight it.\nfunction mouseOver(event)\n{\n  lastMouseOverEvent = event;\n\n  getBlockableElementOrAncestor(event.target, element =>\n  {\n    if (event == lastMouseOverEvent)\n    {\n      lastMouseOverEvent = null;\n\n      if (currentlyPickingElement)\n      {\n        if (currentElement)\n          unhighlightElement(currentElement);\n\n        if (element)\n          highlightElement(element, \"#d6d84b\", \"#f8fa47\");\n\n        currentElement = element;\n      }\n    }\n  });\n\n  event.stopPropagation();\n}\n\n// No longer hovering over this element so unhighlight it.\nfunction mouseOut(event)\n{\n  if (!currentlyPickingElement || currentElement != event.target)\n    return;\n\n  unhighlightElement(currentElement);\n  event.stopPropagation();\n}\n\n// Key events - Return selects currently hovered-over element, escape aborts.\nfunction keyDown(event)\n{\n  if (!event.ctrlKey && !event.altKey && !event.shiftKey)\n  {\n    if (event.keyCode == 13) // Return\n      elementPicked(event);\n    else if (event.keyCode == 27) // Escape\n      deactivateBlockElement();\n  }\n}\n\n\n/* Element selection */\n\n// Start highlighting elements yellow as the mouse moves over them, when one is\n// chosen launch the popup dialog for the user to confirm the generated filters.\nfunction startPickingElement()\n{\n  currentlyPickingElement = true;\n\n  // Add (currently invisible) overlays for blockable elements that don't emit\n  // mouse events, so that they can still be selected.\n  Array.prototype.forEach.call(\n    document.querySelectorAll(\"object,embed,iframe,frame\"),\n    element =>\n    {\n      getFiltersForElement(element, filters =>\n      {\n        if (filters.length > 0)\n          addElementOverlay(element);\n      });\n    }\n  );\n\n  document.addEventListener(\"mousedown\", stopEventPropagation, true);\n  document.addEventListener(\"mouseup\", stopEventPropagation, true);\n  document.addEventListener(\"mouseenter\", stopEventPropagation, true);\n  document.addEventListener(\"mouseleave\", stopEventPropagation, true);\n  document.addEventListener(\"mouseover\", mouseOver, true);\n  document.addEventListener(\"mouseout\", mouseOut, true);\n  document.addEventListener(\"click\", elementPicked, true);\n  document.addEventListener(\"contextmenu\", elementPicked, true);\n  document.addEventListener(\"keydown\", keyDown, true);\n\n  ext.onExtensionUnloaded.addListener(deactivateBlockElement);\n}\n\n// The user has picked an element - currentElement. Highlight it red, generate\n// filters for it and open a popup dialog so that the user can confirm.\nfunction elementPicked(event)\n{\n  if (!currentElement)\n    return;\n\n  let element = currentElement.prisoner || currentElement;\n  getFiltersForElement(element, (filters, selectors) =>\n  {\n    if (currentlyPickingElement)\n      stopPickingElement();\n\n    browser.runtime.sendMessage({\n      type: \"composer.openDialog\",\n      filters\n    }, popupId =>\n    {\n      // Only the top frame keeps a record of the popup window's ID,\n      // so if this isn't the top frame we need to pass the ID on.\n      if (window == window.top)\n      {\n        blockelementPopupId = popupId;\n      }\n      else\n      {\n        browser.runtime.sendMessage({\n          type: \"composer.forward\",\n          payload: {type: \"composer.content.dialogOpened\", popupId}\n        });\n      }\n    });\n\n    if (selectors.length > 0)\n      highlightElements(selectors.join(\",\"));\n\n    highlightElement(currentElement, \"#fd1708\", \"#f6a1b5\");\n  });\n\n  event.preventDefault();\n  event.stopPropagation();\n}\n\nfunction stopPickingElement()\n{\n  currentlyPickingElement = false;\n\n  document.removeEventListener(\"mousedown\", stopEventPropagation, true);\n  document.removeEventListener(\"mouseup\", stopEventPropagation, true);\n  document.removeEventListener(\"mouseenter\", stopEventPropagation, true);\n  document.removeEventListener(\"mouseleave\", stopEventPropagation, true);\n  document.removeEventListener(\"mouseover\", mouseOver, true);\n  document.removeEventListener(\"mouseout\", mouseOut, true);\n  document.removeEventListener(\"click\", elementPicked, true);\n  document.removeEventListener(\"contextmenu\", elementPicked, true);\n  document.removeEventListener(\"keydown\", keyDown, true);\n}\n\n\n/* Core logic */\n\n// We're done with the block element feature for now, tidy everything up.\nfunction deactivateBlockElement(popupAlreadyClosed)\n{\n  if (currentlyPickingElement)\n    stopPickingElement();\n\n  if (blockelementPopupId != null && !popupAlreadyClosed)\n  {\n    browser.runtime.sendMessage({\n      type: \"composer.forward\",\n      targetPageId: blockelementPopupId,\n      payload:\n      {\n        type: \"composer.dialog.close\"\n      }\n    });\n  }\n\n  blockelementPopupId = null;\n  lastRightClickEvent = null;\n\n  if (currentElement)\n  {\n    unhighlightElement(currentElement);\n    currentElement = null;\n  }\n  unhighlightElements();\n\n  let overlays = document.getElementsByClassName(\"__adblockplus__overlay\");\n  while (overlays.length > 0)\n    overlays[0].parentNode.removeChild(overlays[0]);\n\n  ext.onExtensionUnloaded.removeListener(deactivateBlockElement);\n}\n\nfunction initializeComposer()\n{\n  if (typeof ext == \"undefined\")\n    return false;\n\n  // Use a contextmenu handler to save the last element the user right-clicked\n  // on. To make things easier, we actually save the DOM event. We have to do\n  // this because the contextMenu API only provides a URL, not the actual DOM\n  // element.\n  //   We also need to make sure that the previous right click event,\n  // if there is one, is removed. We don't know which frame it is in so we must\n  // send a message to the other frames to clear their old right click events.\n  document.addEventListener(\"contextmenu\", event =>\n  {\n    lastRightClickEvent = event;\n    lastRightClickEventIsMostRecent = true;\n\n    browser.runtime.sendMessage({\n      type: \"composer.forward\",\n      payload:\n      {\n        type: \"composer.content.clearPreviousRightClickEvent\"\n      }\n    });\n  }, true);\n\n  ext.onMessage.addListener((message, sender, sendResponse) =>\n  {\n    switch (message.type)\n    {\n      case \"composer.content.getState\":\n        if (window == window.top)\n        {\n          sendResponse({\n            active: currentlyPickingElement || blockelementPopupId != null\n          });\n        }\n        break;\n      case \"composer.content.startPickingElement\":\n        if (window == window.top)\n          startPickingElement();\n        break;\n      case \"composer.content.contextMenuClicked\":\n        let event = lastRightClickEvent;\n        deactivateBlockElement();\n        if (event)\n        {\n          getBlockableElementOrAncestor(event.target, element =>\n          {\n            if (element)\n            {\n              currentElement = element;\n              elementPicked(event);\n            }\n          });\n        }\n        break;\n      case \"composer.content.finished\":\n        if (currentElement && message.remove)\n        {\n          // Hide the selected element itself if an added blocking\n          // filter is causing it to collapse. Note that this\n          // behavior is incomplete, but the best we can do here,\n          // e.g. if an added blocking filter matches other elements,\n          // the effect won't be visible until the page is is reloaded.\n          checkCollapse(currentElement.prisoner || currentElement);\n\n          // Apply added element hiding filters.\n          elemhide.apply();\n        }\n        deactivateBlockElement(!!message.popupAlreadyClosed);\n        break;\n      case \"composer.content.clearPreviousRightClickEvent\":\n        if (!lastRightClickEventIsMostRecent)\n          lastRightClickEvent = null;\n        lastRightClickEventIsMostRecent = false;\n        break;\n      case \"composer.content.dialogOpened\":\n        if (window == window.top)\n          blockelementPopupId = message.popupId;\n        break;\n      case \"composer.content.dialogClosed\":\n        // The onRemoved hook for the popup can create a race condition, so we\n        // to be careful here. (This is not perfect, but best we can do.)\n        if (window == window.top && blockelementPopupId == message.popupId)\n        {\n          browser.runtime.sendMessage({\n            type: \"composer.forward\",\n            payload:\n            {\n              type: \"composer.content.finished\",\n              popupAlreadyClosed: true\n            }\n          });\n        }\n        break;\n    }\n  });\n\n  if (window == window.top)\n    browser.runtime.sendMessage({type: \"composer.ready\"});\n\n  return true;\n}\n\nif (document instanceof HTMLDocument)\n{\n  // There's a bug in Firefox that causes document_end content scripts to run\n  // before document_start content scripts on extension startup. In this case\n  // the ext object is undefined, we fail to initialize, and initializeComposer\n  // returns false. As a workaround, try again after a timeout.\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1395287\n  if (!initializeComposer())\n    setTimeout(initializeComposer, 2000);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./composer.postload.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}